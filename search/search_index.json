{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"unrest - Simple sqlalchemy rest api generation. from unrest import UnRest # First, initialize UnRest with your web application rest = UnRest(app) # Then declare your endpoint rest(Person) This should provides you a /api/person and a /api/person/<login> route accessible in GET only. To activate data modification, set the methods array like this: rest(Person, only=['name', 'sex', 'age'], methods=['GET', 'PUT', 'POST', 'DELETE', 'PATCH']) # or simply methods=rest.all You will get both routes on the four methods. Please see the wikipedia page for their signification. You can also override the default methods like this: person = rest(Person) @person.declare('GET') def get(payload, login=None): # Pre get hook if login: login = login.upper() rv = person.get(payload, login=login) # Post get hook return { 'occurences': rv['occurences'], 'objects': [ {'login': person['login'].lower()} for person in rv['objects'] ] } Documentation Full documentation can be found at kozea.github.io/unrest Example Consider this simple web application: from datetime import timedelta from flask import Flask from flask_sqlalchemy import SQLAlchemy from sqlalchemy.orm import relationship from sqlalchemy.sql.schema import Column, ForeignKey from sqlalchemy.types import Integer, Interval, Numeric, String from unrest import UnRest # Flask application app = Flask(__name__) app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/unrest.db' # Model definition db = SQLAlchemy(app) class Tree(db.Model): id = Column(Integer, primary_key=True) name = Column(String) @property def fruit_colors(self): return ', '.join([fruit.color for fruit in self.fruits]) class Fruit(db.Model): fruit_id = Column(Integer, primary_key=True) color = Column(String(50)) size = Column(Numeric) age = Column(Interval) tree_id = Column(Integer, ForeignKey('tree.id')) tree = relationship(Tree, backref='fruits') # Drop everything just in case db.drop_all() # Create model db.create_all() # Data insertion pine = Tree(name='pine') maple = Tree(name='maple') oak = Tree(name='oak') db.session.add(pine) db.session.add(maple) db.session.add(oak) db.session.add(Fruit(color='grey', size=12, age=timedelta(days=12, hours=1, minutes=15), tree=pine)) db.session.add(Fruit(color='darkgrey', size=23, age=timedelta(days=49, seconds=230, milliseconds=213), tree=pine)) db.session.add(Fruit(color='brown', size=2.12, age=timedelta(0), tree=pine)) db.session.add(Fruit(color='red', size=.5, age=timedelta(minutes=40), tree=maple)) db.session.add(Fruit(color='orangered', size=100, age=timedelta(hours=2, microseconds=12), tree=maple)) db.session.commit() db.session.remove() # Declare rest endpoints rest = UnRest(app, db.session) # Authorize every methods rest(Tree, methods=rest.all, allow_batch=True) # Don't authorize batch for fruits rest(Fruit, methods=rest.all) # Run the app app.run(debug=True) You will now have: GET With primary keys arguments $ curl -s http://localhost:5000/api/tree/1 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"pine\" } ] } $ curl -s http://localhost:5000/api/fruit/1 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 } ] } Without argument $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 3, \"objects\": [ { \"id\": 1, \"name\": \"pine\" }, { \"id\": 2, \"name\": \"maple\" }, { \"id\": 3, \"name\": \"oak\" } ] } $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 5, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 } ] } PUT With primary keys arguments $ curl -s http://localhost:5000/api/tree/1 -X PUT -H \"Content-Type: application/json\" -d '{ \"name\": \"cedar\" }' 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"cedar\" } ] } Get it again to be sure: $ curl -s http://localhost:5000/api/tree/1 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"cedar\" } ] } Without argument $ curl -s http://localhost:5000/api/tree -X PUT -H \"Content-Type: application/json\" -d '{ \"objects\": [{\"id\": 2, \"name\": \"cedar\"}, {\"id\": 22, \"name\": \"mango\"}] }' 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 22, \"name\": \"mango\" } ] } Get it again to be sure: $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 22, \"name\": \"mango\" } ] } Check that when allow_batch is not set we can't put all: $ curl -s http://localhost:5000/api/fruit -X PUT -H \"Content-Type: application/json\" -d '{ \"objects\": [ {\"fruit_id\": 2, \"color\": \"red\"}, {\"fruit_id\": 22, \"color\": \"blue\"} ] }' 406 Not Acceptable { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } POST With primary keys arguments $ curl -s http://localhost:5000/api/tree/1 -X POST -H \"Content-Type: application/json\" 501 Not Implemented { \"message\": \"POST on id corresponds to collection creation. It's not implemented by default. If you want to update an item use the PUT method instead\" } Without argument $ curl -s http://localhost:5000/api/fruit -X POST -H \"Content-Type: application/json\" -d '{ \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 }' 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] } Now we should have a total of 6 fruits: $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 6, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 }, { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] } DELETE With primary keys arguments $ curl -s http://localhost:5000/api/fruit/3 -X DELETE 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 } ] } Now we should have only 5 fruits remaining: $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 5, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 }, { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] } Without argument Batch delete is not allowed on fruit: $ curl -s http://localhost:5000/api/fruit -X DELETE 501 Not Implemented { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } But is on tree: $ curl -s http://localhost:5000/api/tree -X DELETE 200 OK { \"occurences\": 3, \"objects\": [ { \"id\": 1, \"name\": \"pine\" }, { \"id\": 2, \"name\": \"maple\" }, { \"id\": 3, \"name\": \"oak\" } ] } $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 0, \"objects\": [] } PATCH With primary keys arguments $ curl -s http://localhost:5000/api/fruit/1 -X PATCH -H \"Content-Type: application/json\" -d '{ \"color\": \"blue\" }' 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 1, \"color\": \"blue\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 } ] } Without argument $ curl -s http://localhost:5000/api/tree -X PATCH -H \"Content-Type: application/json\" -d '{ \"objects\": [{\"id\": 2, \"name\": \"cedar\"}, {\"id\": 3, \"name\": \"mango\"}] }' 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 3, \"name\": \"mango\" } ] } Check that when allow_batch is not set we can't put all: $ curl -s http://localhost:5000/api/fruit -X PATCH -H \"Content-Type: application/json\" -d '{ \"objects\": [ {\"fruit_id\": 1, \"color\": \"blue\"}, {\"fruit_id\": 3, \"age\": 1038540.0}, {\"fruit_id\": 4, \"color\": \"rainbow\", \"size\": 8}, {\"fruit_id\": 5, \"size\": 10, \"tree_id\": 1} ] }' 406 Not Acceptable { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } otherwise all the specified attributes would have been patched.","title":"Home"},{"location":"#unrest-simple-sqlalchemy-rest-api-generation","text":"from unrest import UnRest # First, initialize UnRest with your web application rest = UnRest(app) # Then declare your endpoint rest(Person) This should provides you a /api/person and a /api/person/<login> route accessible in GET only. To activate data modification, set the methods array like this: rest(Person, only=['name', 'sex', 'age'], methods=['GET', 'PUT', 'POST', 'DELETE', 'PATCH']) # or simply methods=rest.all You will get both routes on the four methods. Please see the wikipedia page for their signification. You can also override the default methods like this: person = rest(Person) @person.declare('GET') def get(payload, login=None): # Pre get hook if login: login = login.upper() rv = person.get(payload, login=login) # Post get hook return { 'occurences': rv['occurences'], 'objects': [ {'login': person['login'].lower()} for person in rv['objects'] ] }","title":"unrest - Simple sqlalchemy rest api generation."},{"location":"#documentation","text":"Full documentation can be found at kozea.github.io/unrest","title":"Documentation"},{"location":"#example","text":"Consider this simple web application: from datetime import timedelta from flask import Flask from flask_sqlalchemy import SQLAlchemy from sqlalchemy.orm import relationship from sqlalchemy.sql.schema import Column, ForeignKey from sqlalchemy.types import Integer, Interval, Numeric, String from unrest import UnRest # Flask application app = Flask(__name__) app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/unrest.db' # Model definition db = SQLAlchemy(app) class Tree(db.Model): id = Column(Integer, primary_key=True) name = Column(String) @property def fruit_colors(self): return ', '.join([fruit.color for fruit in self.fruits]) class Fruit(db.Model): fruit_id = Column(Integer, primary_key=True) color = Column(String(50)) size = Column(Numeric) age = Column(Interval) tree_id = Column(Integer, ForeignKey('tree.id')) tree = relationship(Tree, backref='fruits') # Drop everything just in case db.drop_all() # Create model db.create_all() # Data insertion pine = Tree(name='pine') maple = Tree(name='maple') oak = Tree(name='oak') db.session.add(pine) db.session.add(maple) db.session.add(oak) db.session.add(Fruit(color='grey', size=12, age=timedelta(days=12, hours=1, minutes=15), tree=pine)) db.session.add(Fruit(color='darkgrey', size=23, age=timedelta(days=49, seconds=230, milliseconds=213), tree=pine)) db.session.add(Fruit(color='brown', size=2.12, age=timedelta(0), tree=pine)) db.session.add(Fruit(color='red', size=.5, age=timedelta(minutes=40), tree=maple)) db.session.add(Fruit(color='orangered', size=100, age=timedelta(hours=2, microseconds=12), tree=maple)) db.session.commit() db.session.remove() # Declare rest endpoints rest = UnRest(app, db.session) # Authorize every methods rest(Tree, methods=rest.all, allow_batch=True) # Don't authorize batch for fruits rest(Fruit, methods=rest.all) # Run the app app.run(debug=True) You will now have:","title":"Example"},{"location":"#get","text":"","title":"GET"},{"location":"#with-primary-keys-arguments","text":"$ curl -s http://localhost:5000/api/tree/1 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"pine\" } ] } $ curl -s http://localhost:5000/api/fruit/1 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 } ] }","title":"With primary keys arguments"},{"location":"#without-argument","text":"$ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 3, \"objects\": [ { \"id\": 1, \"name\": \"pine\" }, { \"id\": 2, \"name\": \"maple\" }, { \"id\": 3, \"name\": \"oak\" } ] } $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 5, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 } ] }","title":"Without argument"},{"location":"#put","text":"","title":"PUT"},{"location":"#with-primary-keys-arguments_1","text":"$ curl -s http://localhost:5000/api/tree/1 -X PUT -H \"Content-Type: application/json\" -d '{ \"name\": \"cedar\" }' 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"cedar\" } ] } Get it again to be sure: $ curl -s http://localhost:5000/api/tree/1 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"cedar\" } ] }","title":"With primary keys arguments"},{"location":"#without-argument_1","text":"$ curl -s http://localhost:5000/api/tree -X PUT -H \"Content-Type: application/json\" -d '{ \"objects\": [{\"id\": 2, \"name\": \"cedar\"}, {\"id\": 22, \"name\": \"mango\"}] }' 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 22, \"name\": \"mango\" } ] } Get it again to be sure: $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 22, \"name\": \"mango\" } ] } Check that when allow_batch is not set we can't put all: $ curl -s http://localhost:5000/api/fruit -X PUT -H \"Content-Type: application/json\" -d '{ \"objects\": [ {\"fruit_id\": 2, \"color\": \"red\"}, {\"fruit_id\": 22, \"color\": \"blue\"} ] }' 406 Not Acceptable { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" }","title":"Without argument"},{"location":"#post","text":"","title":"POST"},{"location":"#with-primary-keys-arguments_2","text":"$ curl -s http://localhost:5000/api/tree/1 -X POST -H \"Content-Type: application/json\" 501 Not Implemented { \"message\": \"POST on id corresponds to collection creation. It's not implemented by default. If you want to update an item use the PUT method instead\" }","title":"With primary keys arguments"},{"location":"#without-argument_2","text":"$ curl -s http://localhost:5000/api/fruit -X POST -H \"Content-Type: application/json\" -d '{ \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 }' 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] } Now we should have a total of 6 fruits: $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 6, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 }, { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] }","title":"Without argument"},{"location":"#delete","text":"","title":"DELETE"},{"location":"#with-primary-keys-arguments_3","text":"$ curl -s http://localhost:5000/api/fruit/3 -X DELETE 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 } ] } Now we should have only 5 fruits remaining: $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 5, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 }, { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] }","title":"With primary keys arguments"},{"location":"#without-argument_3","text":"Batch delete is not allowed on fruit: $ curl -s http://localhost:5000/api/fruit -X DELETE 501 Not Implemented { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } But is on tree: $ curl -s http://localhost:5000/api/tree -X DELETE 200 OK { \"occurences\": 3, \"objects\": [ { \"id\": 1, \"name\": \"pine\" }, { \"id\": 2, \"name\": \"maple\" }, { \"id\": 3, \"name\": \"oak\" } ] } $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 0, \"objects\": [] }","title":"Without argument"},{"location":"#patch","text":"","title":"PATCH"},{"location":"#with-primary-keys-arguments_4","text":"$ curl -s http://localhost:5000/api/fruit/1 -X PATCH -H \"Content-Type: application/json\" -d '{ \"color\": \"blue\" }' 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 1, \"color\": \"blue\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 } ] }","title":"With primary keys arguments"},{"location":"#without-argument_4","text":"$ curl -s http://localhost:5000/api/tree -X PATCH -H \"Content-Type: application/json\" -d '{ \"objects\": [{\"id\": 2, \"name\": \"cedar\"}, {\"id\": 3, \"name\": \"mango\"}] }' 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 3, \"name\": \"mango\" } ] } Check that when allow_batch is not set we can't put all: $ curl -s http://localhost:5000/api/fruit -X PATCH -H \"Content-Type: application/json\" -d '{ \"objects\": [ {\"fruit_id\": 1, \"color\": \"blue\"}, {\"fruit_id\": 3, \"age\": 1038540.0}, {\"fruit_id\": 4, \"color\": \"rainbow\", \"size\": 8}, {\"fruit_id\": 5, \"size\": 10, \"tree_id\": 1} ] }' 406 Not Acceptable { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } otherwise all the specified attributes would have been patched.","title":"Without argument"},{"location":"coercers/","text":"unrest.coercers Serialize Serialize(self, model, columns, properties, relationships) Base serializer class Casts python sqlalchemy data into a JSON compliant type according to the sqlalchemy column type. Not all types are implemented as of now and it's fairly easy to add: Just add a serialize_type method for type and it shall work. The serialize class can be configured with the rest function and on the UnRest declaration. For example: from unrest.coercers import Serialize class BetterSerialize(Serialize): def serialize_matrix(self, type, data): return data.matrix_to_string() rest = UnRest(app, session, SerializeClass=BetterSerialize) ... Arguments model : The sqlachemy item to serialize. columns : The list of columns to serialize. properties : The list of properties to serialize. relationships : The list of relationships to serialize. dict Serialize.dict(self) Serialize the given model to a JSON compatible dict Deserialize Deserialize(self, payload, columns) Base deserializer class Casts JSON data back to compatible python sqlalchemy type. Not all types are implemented as of now and it's fairly easy to add: Just add a deserialize_type method for type and it shall work. The deserialize class can be configured with the rest function and on the UnRest declaration. For example: from unrest.coercers import Deserialize class BetterDeserialize(Deserialize): def deserialize_matrix(self, type, data): return Matrix.from_string(data) rest = UnRest(app, session, DeserializeClass=BetterDeserialize) ... Arguments payload : The JSON payload to deserialize columns : The list of columns to deserialize merge Deserialize.merge(self, item, payload=None) Deserialize the given payload into the existing sqlalchemy item create Deserialize.create(self, factory) Deserialize objects in the given payload into a list of new items created with the factory function.","title":"Serialization/Deserialization"},{"location":"flask_framework/","text":"unrest.flask_framework FlaskUnRest FlaskUnRest(self, app, prefix) Unrest flask framework implementation. This is the framework abstraction you can implement for your own framework url Return the api url root register_route FlaskUnRest.register_route(self, path, method, parameters, fun) Register the given function for path and method with and without parameters . Arguments path : The url of the endoint without arguments. ('/api/person') method : The HTTP method to register the route on. parameters : The primary keys of the model that can be given after the path. PrimaryKey('id'), PrimaryKey('type')) -> '/api/person/<id>/<type>' fun : The route function request_json FlaskUnRest.request_json(self) Must return the string of the current JSON request content or None send_json FlaskUnRest.send_json(self, json, status_code=200) Send a status_code JSON response with json as content Arguments json : The JSON string to send. status_code : The response status code. (Default: 200) send_error FlaskUnRest.send_error(self, message, status_code) Send an error as a JSON response with the given status code. Arguments message : The JSON string containing the error message. status_code : The HTTP status code (i.e. 402)","title":"Flask"},{"location":"framework/","text":"unrest.framework.simple SimpleUnRest SimpleUnRest(self, app, prefix) Unrest tornado framework implementation. This is the framework abstraction you can implement for your own framework url Return the api url root register_route SimpleUnRest.register_route(self, path, method, parameters, fun) Register the given function for path and method with and without parameters . Arguments path : The url of the endoint without arguments. ('/api/person') method : The HTTP method to register the route on. parameters : The primary keys of the model that can be given after the path. PrimaryKey('id'), PrimaryKey('type')) -> '/api/person/<id>/<type>' fun : The route function unrest.framework.flask FlaskUnRest FlaskUnRest(self, app, prefix) Unrest flask framework implementation. This is the framework abstraction you can implement for your own framework url Return the api url root register_route FlaskUnRest.register_route(self, path, method, parameters, fun) Register the given function for path and method with and without parameters . Arguments path : The url of the endoint without arguments. ('/api/person') method : The HTTP method to register the route on. parameters : The primary keys of the model that can be given after the path. PrimaryKey('id'), PrimaryKey('type')) -> '/api/person/<id>/<type>' fun : The route function unrest.framework.tornado TornadoUnRest TornadoUnRest(self, app, prefix) Unrest tornado framework implementation. This is the framework abstraction you can implement for your own framework url Return the api url root register_route TornadoUnRest.register_route(self, path, method, parameters, fun) Register the given function for path and method with and without parameters . Arguments path : The url of the endoint without arguments. ('/api/person') method : The HTTP method to register the route on. parameters : The primary keys of the model that can be given after the path. PrimaryKey('id'), PrimaryKey('type')) -> '/api/person/<id>/<type>' fun : The route function","title":"Framework"},{"location":"generators/","text":"unrest.generators.openapi unrest.generators.options","title":"Generators"},{"location":"idiom/","text":"unrest.idiom.unrest unrest.idiom.yaml unrest.idiom.json_server JsonServerIdiom JsonServerIdiom(self, rest) PK_DELIM str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object. str () (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.","title":"Idiom"},{"location":"rest/","text":"unrest.rest call_me_maybe call_me_maybe(fun_or_value, *args, **kwargs) Call first argument {fun_or_value} with { args}, { *kwargs} if it is callable, return it otherwise. identity identity(arg) Identity function, return {arg} Rest Rest(self, unrest, Model, methods=['GET'], name=None, only=None, exclude=None, query=None, properties=None, relationships=None, allow_batch=False, auth=None, read_auth=None, write_auth=None, validators=None, validation_error_code=500, primary_keys=None, defaults=None, fixed=None, IdiomClass=<class 'unrest.idiom.unrest.UnRestIdiom'>, SerializeClass=<class 'unrest.coercers.Serialize'>, DeserializeClass=<class 'unrest.coercers.Deserialize'>) This is the entry point for generating a REST endpoint for a specific model The final uri if the path is '/api' and version 'v2' would be: /api/v2/model and /api/v2/model/pk1/pk2 and if model is not in the public schema /api/v2/schema/model and /api/v2/schema/model/pk1/pk2 . Usage: rest = UnRest(app) def name_validator(field): if len(field.value) > 12: raise field.ValidationError( 'Name is too long (max 12 characters).') return field.value rest(Person, only=['name', 'sex', 'age'], methods=rest.all, query=lambda q: q.filter(Person.age > 16), validators={'name': name_validator}) Arguments unrest : The unrest instance given automatically on UnRest call. Model : The sqlalchemy orm model class. methods : The allowed method list on this endpoint. Possible values are GET, PUT, POST, DELETE, PATCH and rest.all name : If specified replaces the model name in url. only : If specified restricts the json fields to this list. exclude : If specified removes the json fields in this list. query : A function that takes the Model query and returns your specific query. Can be useful to filter data for all the methods. properties : A list of additional properties to retrieve on the model. relationships : A mapping of relationships and rest endpoints to fetch with the model. allow_batch : Allow batch operations (PUT, DELETE and PATCH) without primary key. auth : A decorator that will always be called. read_auth : A decorator that will be called on GET. write_auth : A decorator that will be called on PUT, POST, DELETE and PATCH. validators : A mapping of field names and validation functions. A validator function takes a Rest.Validatable object as parameter and must return the final value for the field or raise a rest.ValidationError(reason) (where rest = Unrest() ) validation_error_code : The http return code when the validation fails. Defaults to 500 primary_keys : A list of column names to use as primary_keys (use real db primary keys by default) defaults : A mapping of column -> values which sets the default value of the columns when the column is not present in the payload. Can be a callable, in this case it will be called at runtime with the payload as argument. fixed : A mapping of column -> values which replaces the values present or not in the payload. Can be a callable, in this case it will be called at runtime with the payload as argument. SerializeClass : An alternative Serialize class. DeserializeClass : An alternative Deserialize class. get Rest.get(self, payload, **pks) The GET method No arguments: Returns all query elements. (/api/model/) Primary keys: Returns the element in query with the primary keys. (/api/model/pk) Arguments payload : The json request content ignored for GET. pks : The primary keys in url if any. put Rest.put(self, payload, **pks) The PUT method No arguments: If allow_batch set to true replace all the query elements with the ones in the request payload. Primary keys: Create or replace the element associated with the primary keys from the one in the request payload. Arguments payload : The json request content containing new elements. pks : The primary keys in url if any. post Rest.post(self, payload, **pks) The POST method No arguments: Add element from request payload. Primary keys: Correspond to new collection creation. Unused. Arguments payload : The json request content containing the new element. pks : The primary keys in url if any. delete Rest.delete(self, payload, **pks) The DELETE method No arguments: If allow_batch set to true delete all query elements. Primary keys: Delete the element associated with the primary keys. Arguments payload : The json request content ignored in DELETE. pks : The primary keys of the element to delete. patch Rest.patch(self, payload, **pks) The PATCH method No arguments: If allow_batch set to true patch existing elements with element attributes specified in the request payload. Primary keys: Patch only one Arguments payload : The json request content containing a list of attributes to be patched. pks : The primary keys of the element to patch. options Rest.options(self, payload, **pks) The OPTIONS method Returns a description of this rest endpoint. declare Rest.declare(self, method, manual_commit=False) A decorator to register an alternative method. The original is still callable with rest.{method} fruit = rest(Fruit) @fruit.declare('GET') def get(payload, fruit_id=None): rv = fruit.get(payload, fruit_id=fruit_id) return { 'occurences': rv['occurences'], 'objects': [ {'id': obj['fruit_id']} for obj in rv['objects'] ] } Arguments method : The method to override ('GET' for exemple) manual_commit : Don't auto commit after the method. sub Rest.sub(self, query_factory, **kwargs) This methods return a copy of the current rest endpoint and takes a {query_factory} argument to alter the current query. Arguments query_factory : A function that takes the original query in parameter and returns a new query. **kwargs : Can be used to override Rest constructor arguments (query is not supported) parameters_to_pks Rest.parameters_to_pks(self, parameters) Transform query parameters into primary keys mapping with deserialized values. serialize Rest.serialize(self, items) Serialize all items and return a mapping containing: - objects: The serialized objects - primary_keys: The list of primary keys defined for this rest endpoint - occurences: The number of total occurences (without limit) - offset if there's a query offset - limit if there's a query limit validate Rest.validate(self, item, existing=None, errors=None) Validates all validators columns against validators. Raise RestError if validation errors.","title":"Rest entry points"},{"location":"unrest/","text":"unrest UnRest UnRest(self, app=None, session=None, path='/api', version='', framework=None, IdiomClass=None, SerializeClass=None, DeserializeClass=None, RestClass=<class 'unrest.rest.Rest'>, allow_options=True, serve_openapi_file=True, openapi_class=<class 'unrest.generators.openapi.OpenApi'>, options_class=<class 'unrest.generators.options.Options'>, empty_get_as_404=False, info={}) A troubling rest api library for sqlalchemy models. This is the main entry point of unrest. Common usage is as following: rest = UnRest(app, session) # app is your application # When called, it instanciate a `Rest` object that will register the # REST endpoints. See the `Rest` class. rest(Model1) rest(Model2) Arguments app : Your web application, can be set afterwards using UnRest.init_app session : Your sqlalchemy session, can be set afterwards using UnRest.init_session and init_session method. path : Default '/api', sets the root url path for your endpoints version : Adds a version to the root url path if specified (i.e. /api/v2) framework : A specific framework class, defaults to auto detect. IdiomClass : An idiom class, defaults to json unrest format. SerializeClass : A global alternative for Serialize class. DeserializeClass : A global alternative for Deserialize class. RestClass : Replace the default Rest class. allow_options : Set it to False to disable OPTIONS requests. serve_openapi_file : Set it to False to disable openapi file generation. empty_get_as_404 : If True return a 404 on get with id not found info : Additional info for the openapi metadata. Unrest aims to be framework agnostic. It currently works with Flask out of the box, for another web framework you will have to implement your own Framework class. See FlaskUnRest in flask_framework.py all Return all supported methods. Useful for the rest method keyword argument. RestError UnRest.RestError(self, status, message, extra=None) Exception raised by rest methods. It's catched by the REST method wrapper and will return a status http error with the specified message . ValidationError UnRest.ValidationError(self, message) Exception raised by rest validation methods. init_app UnRest.init_app(self, app) Sets the app on UnRest if it was missing during instantiation. init_session UnRest.init_session(self, session) Sets the sqlalchemy session on UnRest if it was missing during instantiation. raise_error UnRest.raise_error(self, status, message, extra=None) Raise an error that will be handled by the rest wrapper, which will return a json response with status as HTTP status code and message as content. Arguments status : The http status code corresponding to the error (404 for instance) message : The message that will be returned in the json response extra : Mapping of extra fields to return in json response __call__ UnRest.__call__(self, *args, **kwargs) Returns a unrest.Rest instance. See rest entry points.","title":"UnRest"},{"location":"util/","text":"Request Request(self, url, method, parameters, query, payload, headers) Response Response(self, payload, headers, status)","title":"Util"}]}