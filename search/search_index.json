{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UnRest - Simple sqlalchemy rest api generation. \uf0c1 from unrest import UnRest # First, initialize UnRest with your web application rest = UnRest(app) # Then declare your endpoint rest(Person) This should provides you a /api/person and a /api/person/<login> route accessible in GET only. To activate data modification, set the methods array like this: rest(Person, only=['name', 'sex', 'age'], methods=['GET', 'PUT', 'POST', 'DELETE', 'PATCH']) # or simply methods=rest.all You will get both routes (collection and member) on the four methods. Please see the wikipedia page for their signification. You can also override the default methods like this: person = rest(Person) @person.declare('GET') def get(payload, login=None): # Pre get hook if login: login = login.upper() rv = person.get(payload, login=login) # Post get hook return { 'occurences': rv['occurences'], 'objects': [ {'login': person['login'].lower()} for person in rv['objects'] ] } Documentation \uf0c1 Full documentation can be found at kozea.github.io/unrest Example \uf0c1 Consider this simple web application: from datetime import timedelta from flask import Flask from flask_sqlalchemy import SQLAlchemy from sqlalchemy.orm import relationship from sqlalchemy.sql.schema import Column, ForeignKey from sqlalchemy.types import Integer, Interval, Numeric, String from unrest import UnRest # Flask application app = Flask(__name__) app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/unrest.db' # Model definition db = SQLAlchemy(app) class Tree(db.Model): id = Column(Integer, primary_key=True) name = Column(String) @property def fruit_colors(self): return ', '.join([fruit.color for fruit in self.fruits]) class Fruit(db.Model): fruit_id = Column(Integer, primary_key=True) color = Column(String(50)) size = Column(Numeric) age = Column(Interval) tree_id = Column(Integer, ForeignKey('tree.id')) tree = relationship(Tree, backref='fruits') # Drop everything just in case db.drop_all() # Create model db.create_all() # Data insertion pine = Tree(name='pine') maple = Tree(name='maple') oak = Tree(name='oak') db.session.add(pine) db.session.add(maple) db.session.add(oak) db.session.add(Fruit(color='grey', size=12, age=timedelta(days=12, hours=1, minutes=15), tree=pine)) db.session.add(Fruit(color='darkgrey', size=23, age=timedelta(days=49, seconds=230, milliseconds=213), tree=pine)) db.session.add(Fruit(color='brown', size=2.12, age=timedelta(0), tree=pine)) db.session.add(Fruit(color='red', size=.5, age=timedelta(minutes=40), tree=maple)) db.session.add(Fruit(color='orangered', size=100, age=timedelta(hours=2, microseconds=12), tree=maple)) db.session.commit() db.session.remove() # Declare rest endpoints rest = UnRest(app, db.session) # Authorize every methods rest(Tree, methods=rest.all, allow_batch=True) # Don't authorize batch for fruits rest(Fruit, methods=rest.all) # Run the app app.run(debug=True) You will now have: GET \uf0c1 With primary keys arguments \uf0c1 $ curl -s http://localhost:5000/api/tree/1 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"pine\" } ] } $ curl -s http://localhost:5000/api/fruit/1 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 } ] } Without argument \uf0c1 $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 3, \"objects\": [ { \"id\": 1, \"name\": \"pine\" }, { \"id\": 2, \"name\": \"maple\" }, { \"id\": 3, \"name\": \"oak\" } ] } $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 5, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 } ] } PUT \uf0c1 With primary keys arguments \uf0c1 $ curl -s http://localhost:5000/api/tree/1 -X PUT -H \"Content-Type: application/json\" -d '{ \"name\": \"cedar\" }' 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"cedar\" } ] } Get it again to be sure: $ curl -s http://localhost:5000/api/tree/1 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"cedar\" } ] } Without argument \uf0c1 $ curl -s http://localhost:5000/api/tree -X PUT -H \"Content-Type: application/json\" -d '{ \"objects\": [{\"id\": 2, \"name\": \"cedar\"}, {\"id\": 22, \"name\": \"mango\"}] }' 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 22, \"name\": \"mango\" } ] } Get it again to be sure: $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 22, \"name\": \"mango\" } ] } Check that when allow_batch is not set we can't put all: $ curl -s http://localhost:5000/api/fruit -X PUT -H \"Content-Type: application/json\" -d '{ \"objects\": [ {\"fruit_id\": 2, \"color\": \"red\"}, {\"fruit_id\": 22, \"color\": \"blue\"} ] }' 406 Not Acceptable { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } POST \uf0c1 With primary keys arguments \uf0c1 $ curl -s http://localhost:5000/api/tree/1 -X POST -H \"Content-Type: application/json\" 501 Not Implemented { \"message\": \"POST on id corresponds to collection creation. It's not implemented by default. If you want to update an item use the PUT method instead\" } Without argument \uf0c1 $ curl -s http://localhost:5000/api/fruit -X POST -H \"Content-Type: application/json\" -d '{ \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 }' 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] } Now we should have a total of 6 fruits: $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 6, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 }, { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] } DELETE \uf0c1 With primary keys arguments \uf0c1 $ curl -s http://localhost:5000/api/fruit/3 -X DELETE 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 } ] } Now we should have only 5 fruits remaining: $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 5, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 }, { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] } Without argument \uf0c1 Batch delete is not allowed on fruit: $ curl -s http://localhost:5000/api/fruit -X DELETE 501 Not Implemented { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } But is on tree: $ curl -s http://localhost:5000/api/tree -X DELETE 200 OK { \"occurences\": 3, \"objects\": [ { \"id\": 1, \"name\": \"pine\" }, { \"id\": 2, \"name\": \"maple\" }, { \"id\": 3, \"name\": \"oak\" } ] } $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 0, \"objects\": [] } PATCH \uf0c1 With primary keys arguments \uf0c1 $ curl -s http://localhost:5000/api/fruit/1 -X PATCH -H \"Content-Type: application/json\" -d '{ \"color\": \"blue\" }' 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 1, \"color\": \"blue\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 } ] } Without argument \uf0c1 $ curl -s http://localhost:5000/api/tree -X PATCH -H \"Content-Type: application/json\" -d '{ \"objects\": [{\"id\": 2, \"name\": \"cedar\"}, {\"id\": 3, \"name\": \"mango\"}] }' 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 3, \"name\": \"mango\" } ] } Check that when allow_batch is not set we can't put all: $ curl -s http://localhost:5000/api/fruit -X PATCH -H \"Content-Type: application/json\" -d '{ \"objects\": [ {\"fruit_id\": 1, \"color\": \"blue\"}, {\"fruit_id\": 3, \"age\": 1038540.0}, {\"fruit_id\": 4, \"color\": \"rainbow\", \"size\": 8}, {\"fruit_id\": 5, \"size\": 10, \"tree_id\": 1} ] }' 406 Not Acceptable { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } otherwise all the specified attributes would have been patched.","title":"Home"},{"location":"#unrest-simple-sqlalchemy-rest-api-generation","text":"from unrest import UnRest # First, initialize UnRest with your web application rest = UnRest(app) # Then declare your endpoint rest(Person) This should provides you a /api/person and a /api/person/<login> route accessible in GET only. To activate data modification, set the methods array like this: rest(Person, only=['name', 'sex', 'age'], methods=['GET', 'PUT', 'POST', 'DELETE', 'PATCH']) # or simply methods=rest.all You will get both routes (collection and member) on the four methods. Please see the wikipedia page for their signification. You can also override the default methods like this: person = rest(Person) @person.declare('GET') def get(payload, login=None): # Pre get hook if login: login = login.upper() rv = person.get(payload, login=login) # Post get hook return { 'occurences': rv['occurences'], 'objects': [ {'login': person['login'].lower()} for person in rv['objects'] ] }","title":"UnRest - Simple sqlalchemy rest api generation."},{"location":"#documentation","text":"Full documentation can be found at kozea.github.io/unrest","title":"Documentation"},{"location":"#example","text":"Consider this simple web application: from datetime import timedelta from flask import Flask from flask_sqlalchemy import SQLAlchemy from sqlalchemy.orm import relationship from sqlalchemy.sql.schema import Column, ForeignKey from sqlalchemy.types import Integer, Interval, Numeric, String from unrest import UnRest # Flask application app = Flask(__name__) app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/unrest.db' # Model definition db = SQLAlchemy(app) class Tree(db.Model): id = Column(Integer, primary_key=True) name = Column(String) @property def fruit_colors(self): return ', '.join([fruit.color for fruit in self.fruits]) class Fruit(db.Model): fruit_id = Column(Integer, primary_key=True) color = Column(String(50)) size = Column(Numeric) age = Column(Interval) tree_id = Column(Integer, ForeignKey('tree.id')) tree = relationship(Tree, backref='fruits') # Drop everything just in case db.drop_all() # Create model db.create_all() # Data insertion pine = Tree(name='pine') maple = Tree(name='maple') oak = Tree(name='oak') db.session.add(pine) db.session.add(maple) db.session.add(oak) db.session.add(Fruit(color='grey', size=12, age=timedelta(days=12, hours=1, minutes=15), tree=pine)) db.session.add(Fruit(color='darkgrey', size=23, age=timedelta(days=49, seconds=230, milliseconds=213), tree=pine)) db.session.add(Fruit(color='brown', size=2.12, age=timedelta(0), tree=pine)) db.session.add(Fruit(color='red', size=.5, age=timedelta(minutes=40), tree=maple)) db.session.add(Fruit(color='orangered', size=100, age=timedelta(hours=2, microseconds=12), tree=maple)) db.session.commit() db.session.remove() # Declare rest endpoints rest = UnRest(app, db.session) # Authorize every methods rest(Tree, methods=rest.all, allow_batch=True) # Don't authorize batch for fruits rest(Fruit, methods=rest.all) # Run the app app.run(debug=True) You will now have:","title":"Example"},{"location":"#get","text":"","title":"GET"},{"location":"#with-primary-keys-arguments","text":"$ curl -s http://localhost:5000/api/tree/1 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"pine\" } ] } $ curl -s http://localhost:5000/api/fruit/1 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 } ] }","title":"With primary keys arguments"},{"location":"#without-argument","text":"$ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 3, \"objects\": [ { \"id\": 1, \"name\": \"pine\" }, { \"id\": 2, \"name\": \"maple\" }, { \"id\": 3, \"name\": \"oak\" } ] } $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 5, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 } ] }","title":"Without argument"},{"location":"#put","text":"","title":"PUT"},{"location":"#with-primary-keys-arguments_1","text":"$ curl -s http://localhost:5000/api/tree/1 -X PUT -H \"Content-Type: application/json\" -d '{ \"name\": \"cedar\" }' 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"cedar\" } ] } Get it again to be sure: $ curl -s http://localhost:5000/api/tree/1 200 OK { \"occurences\": 1, \"objects\": [ { \"id\": 1, \"name\": \"cedar\" } ] }","title":"With primary keys arguments"},{"location":"#without-argument_1","text":"$ curl -s http://localhost:5000/api/tree -X PUT -H \"Content-Type: application/json\" -d '{ \"objects\": [{\"id\": 2, \"name\": \"cedar\"}, {\"id\": 22, \"name\": \"mango\"}] }' 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 22, \"name\": \"mango\" } ] } Get it again to be sure: $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 22, \"name\": \"mango\" } ] } Check that when allow_batch is not set we can't put all: $ curl -s http://localhost:5000/api/fruit -X PUT -H \"Content-Type: application/json\" -d '{ \"objects\": [ {\"fruit_id\": 2, \"color\": \"red\"}, {\"fruit_id\": 22, \"color\": \"blue\"} ] }' 406 Not Acceptable { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" }","title":"Without argument"},{"location":"#post","text":"","title":"POST"},{"location":"#with-primary-keys-arguments_2","text":"$ curl -s http://localhost:5000/api/tree/1 -X POST -H \"Content-Type: application/json\" 501 Not Implemented { \"message\": \"POST on id corresponds to collection creation. It's not implemented by default. If you want to update an item use the PUT method instead\" }","title":"With primary keys arguments"},{"location":"#without-argument_2","text":"$ curl -s http://localhost:5000/api/fruit -X POST -H \"Content-Type: application/json\" -d '{ \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 }' 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] } Now we should have a total of 6 fruits: $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 6, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 }, { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] }","title":"Without argument"},{"location":"#delete","text":"","title":"DELETE"},{"location":"#with-primary-keys-arguments_3","text":"$ curl -s http://localhost:5000/api/fruit/3 -X DELETE 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 3, \"color\": \"brown\", \"size\": 2.12, \"age\": 0.0, \"tree_id\": 1 } ] } Now we should have only 5 fruits remaining: $ curl -s http://localhost:5000/api/fruit 200 OK { \"occurences\": 5, \"objects\": [ { \"fruit_id\": 1, \"color\": \"grey\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 }, { \"fruit_id\": 2, \"color\": \"darkgrey\", \"size\": 23.0, \"age\": 4233830.213, \"tree_id\": 1 }, { \"fruit_id\": 4, \"color\": \"red\", \"size\": 0.5, \"age\": 2400.0, \"tree_id\": 2 }, { \"fruit_id\": 5, \"color\": \"orangered\", \"size\": 100.0, \"age\": 7200.000012, \"tree_id\": 2 }, { \"fruit_id\": 6, \"color\": \"forestgreen\", \"size\": 3.14, \"age\": 1.5926, \"tree_id\": 3 } ] }","title":"With primary keys arguments"},{"location":"#without-argument_3","text":"Batch delete is not allowed on fruit: $ curl -s http://localhost:5000/api/fruit -X DELETE 501 Not Implemented { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } But is on tree: $ curl -s http://localhost:5000/api/tree -X DELETE 200 OK { \"occurences\": 3, \"objects\": [ { \"id\": 1, \"name\": \"pine\" }, { \"id\": 2, \"name\": \"maple\" }, { \"id\": 3, \"name\": \"oak\" } ] } $ curl -s http://localhost:5000/api/tree 200 OK { \"occurences\": 0, \"objects\": [] }","title":"Without argument"},{"location":"#patch","text":"","title":"PATCH"},{"location":"#with-primary-keys-arguments_4","text":"$ curl -s http://localhost:5000/api/fruit/1 -X PATCH -H \"Content-Type: application/json\" -d '{ \"color\": \"blue\" }' 200 OK { \"occurences\": 1, \"objects\": [ { \"fruit_id\": 1, \"color\": \"blue\", \"size\": 12.0, \"age\": 1041300.0, \"tree_id\": 1 } ] }","title":"With primary keys arguments"},{"location":"#without-argument_4","text":"$ curl -s http://localhost:5000/api/tree -X PATCH -H \"Content-Type: application/json\" -d '{ \"objects\": [{\"id\": 2, \"name\": \"cedar\"}, {\"id\": 3, \"name\": \"mango\"}] }' 200 OK { \"occurences\": 2, \"objects\": [ { \"id\": 2, \"name\": \"cedar\" }, { \"id\": 3, \"name\": \"mango\" } ] } Check that when allow_batch is not set we can't put all: $ curl -s http://localhost:5000/api/fruit -X PATCH -H \"Content-Type: application/json\" -d '{ \"objects\": [ {\"fruit_id\": 1, \"color\": \"blue\"}, {\"fruit_id\": 3, \"age\": 1038540.0}, {\"fruit_id\": 4, \"color\": \"rainbow\", \"size\": 8}, {\"fruit_id\": 5, \"size\": 10, \"tree_id\": 1} ] }' 406 Not Acceptable { \"message\": \"You must set allow_batch to True if you want to use batch methods.\" } otherwise all the specified attributes would have been patched.","title":"Without argument"},{"location":"coercers/","text":"unrest.coercers \uf0c1 Property \uf0c1 Property(self, name, type=None, formatter=None) A Property wrapper used instead of a string in a Rest properties parameter. Arguments name : This property name type : The sqlalchemy type used for type coercion formatter : An optional function to transform the parameter as string Serialize \uf0c1 Serialize(self, model, columns, properties, relationships) Base serializer class Casts python sqlalchemy data into a JSON compliant type according to the sqlalchemy column type. Not all types are implemented as of now and it's fairly easy to add: Just add a serialize_type method for type and it shall work. The serialize class can be configured with the rest function and on the UnRest declaration. For example: from unrest.coercers import Serialize class BetterSerialize(Serialize): def serialize_matrix(self, type, data): return data.matrix_to_string() rest = UnRest(app, session, SerializeClass=BetterSerialize) ... Arguments model : The sqlachemy item to serialize. columns : The list of columns to serialize. properties : The list of properties to serialize. relationships : The list of relationships to serialize. dict \uf0c1 Serialize.dict(self) Serialize the given model to a JSON compatible dict Deserialize \uf0c1 Deserialize(self, payload, columns) Base deserializer class Casts raw data back to compatible python sqlalchemy type. Not all types are implemented as of now and it's fairly easy to add: Just add a deserialize_type method for type and it shall work. The deserialize class can be configured with the rest function and on the UnRest declaration. For example: from unrest.coercers import Deserialize class BetterDeserialize(Deserialize): def deserialize_matrix(self, type, data): return Matrix.from_string(data) rest = UnRest(app, session, DeserializeClass=BetterDeserialize) ... Arguments payload : The payload to deserialize columns : The list of columns to deserialize merge \uf0c1 Deserialize.merge(self, item, payload=None) Deserialize the given payload into the existing sqlalchemy item create \uf0c1 Deserialize.create(self, factory) Deserialize objects in the given payload into a list of new items created with the factory function.","title":"Serialization/Deserialization"},{"location":"coercers/#unrestcoercers","text":"","title":"unrest.coercers"},{"location":"coercers/#property","text":"Property(self, name, type=None, formatter=None) A Property wrapper used instead of a string in a Rest properties parameter. Arguments name : This property name type : The sqlalchemy type used for type coercion formatter : An optional function to transform the parameter as string","title":"Property"},{"location":"coercers/#serialize","text":"Serialize(self, model, columns, properties, relationships) Base serializer class Casts python sqlalchemy data into a JSON compliant type according to the sqlalchemy column type. Not all types are implemented as of now and it's fairly easy to add: Just add a serialize_type method for type and it shall work. The serialize class can be configured with the rest function and on the UnRest declaration. For example: from unrest.coercers import Serialize class BetterSerialize(Serialize): def serialize_matrix(self, type, data): return data.matrix_to_string() rest = UnRest(app, session, SerializeClass=BetterSerialize) ... Arguments model : The sqlachemy item to serialize. columns : The list of columns to serialize. properties : The list of properties to serialize. relationships : The list of relationships to serialize.","title":"Serialize"},{"location":"coercers/#dict","text":"Serialize.dict(self) Serialize the given model to a JSON compatible dict","title":"dict"},{"location":"coercers/#deserialize","text":"Deserialize(self, payload, columns) Base deserializer class Casts raw data back to compatible python sqlalchemy type. Not all types are implemented as of now and it's fairly easy to add: Just add a deserialize_type method for type and it shall work. The deserialize class can be configured with the rest function and on the UnRest declaration. For example: from unrest.coercers import Deserialize class BetterDeserialize(Deserialize): def deserialize_matrix(self, type, data): return Matrix.from_string(data) rest = UnRest(app, session, DeserializeClass=BetterDeserialize) ... Arguments payload : The payload to deserialize columns : The list of columns to deserialize","title":"Deserialize"},{"location":"coercers/#merge","text":"Deserialize.merge(self, item, payload=None) Deserialize the given payload into the existing sqlalchemy item","title":"merge"},{"location":"coercers/#create","text":"Deserialize.create(self, factory) Deserialize objects in the given payload into a list of new items created with the factory function.","title":"create"},{"location":"framework/","text":"unrest.framework \uf0c1 Framework \uf0c1 Framework(self, app, prefix) UnRest Framework abstract class. Framework are instanciated with an app object which should be your framework instance and the prefix of this UnRest instance. You must implement the register_route method if you want to implement you own framework. Arguments app : Your framework instance used in register_route to register route. prefix : The current UnRest url prefix ('api' by default) url \uf0c1 A property returning the api url root. (Used in OPTIONS and openapi genration) register_route \uf0c1 Framework.register_route(self, path, method, parameters, function) This method is called by your rest endpoints for each path and each method that should respond with the function . The route should allow optionally the parameters within the url. These parameters represent the primary keys. Arguments path : The url of the endoint without arguments. ('/api/person') method : The HTTP method to register the route on. parameters : The primary keys of the model that can be given after the path. PrimaryKey('id'), PrimaryKey('type')) -> '/api/person/<id>/<type>' function : The route function unrest.framework.http_server \uf0c1 HTTPServerFramework \uf0c1 HTTPServerFramework(self, app, prefix) Unrest Framework implementation for http.server.HTTPServer compatible app. This exemple implementation requires no external library. unrest.framework.flask \uf0c1 FlaskFramework \uf0c1 FlaskFramework(self, app, prefix) Unrest Framework implementation for Flask. Requires flask to be installed. unrest.framework.tornado \uf0c1 TornadoFramework \uf0c1 TornadoFramework(self, app, prefix) Unrest Framework implementation for Tornado. Requires tornado to be installed.","title":"Frameworks"},{"location":"framework/#unrestframework","text":"","title":"unrest.framework"},{"location":"framework/#framework","text":"Framework(self, app, prefix) UnRest Framework abstract class. Framework are instanciated with an app object which should be your framework instance and the prefix of this UnRest instance. You must implement the register_route method if you want to implement you own framework. Arguments app : Your framework instance used in register_route to register route. prefix : The current UnRest url prefix ('api' by default)","title":"Framework"},{"location":"framework/#url","text":"A property returning the api url root. (Used in OPTIONS and openapi genration)","title":"url"},{"location":"framework/#register_route","text":"Framework.register_route(self, path, method, parameters, function) This method is called by your rest endpoints for each path and each method that should respond with the function . The route should allow optionally the parameters within the url. These parameters represent the primary keys. Arguments path : The url of the endoint without arguments. ('/api/person') method : The HTTP method to register the route on. parameters : The primary keys of the model that can be given after the path. PrimaryKey('id'), PrimaryKey('type')) -> '/api/person/<id>/<type>' function : The route function","title":"register_route"},{"location":"framework/#unrestframeworkhttp_server","text":"","title":"unrest.framework.http_server"},{"location":"framework/#httpserverframework","text":"HTTPServerFramework(self, app, prefix) Unrest Framework implementation for http.server.HTTPServer compatible app. This exemple implementation requires no external library.","title":"HTTPServerFramework"},{"location":"framework/#unrestframeworkflask","text":"","title":"unrest.framework.flask"},{"location":"framework/#flaskframework","text":"FlaskFramework(self, app, prefix) Unrest Framework implementation for Flask. Requires flask to be installed.","title":"FlaskFramework"},{"location":"framework/#unrestframeworktornado","text":"","title":"unrest.framework.tornado"},{"location":"framework/#tornadoframework","text":"TornadoFramework(self, app, prefix) Unrest Framework implementation for Tornado. Requires tornado to be installed.","title":"TornadoFramework"},{"location":"generators/","text":"unrest.generators.openapi \uf0c1 OpenApi \uf0c1 OpenApi(self, unrest) This class generates an openapi v3.0.0 compatible object from the given unrest.UnRest object. unrest.generators.options \uf0c1 Options \uf0c1 Options(self, unrest) This generates an informative object on the unrest.UnRest instance used as reply for http OPTIONS request on the unrest API index.","title":"Generators"},{"location":"generators/#unrestgeneratorsopenapi","text":"","title":"unrest.generators.openapi"},{"location":"generators/#openapi","text":"OpenApi(self, unrest) This class generates an openapi v3.0.0 compatible object from the given unrest.UnRest object.","title":"OpenApi"},{"location":"generators/#unrestgeneratorsoptions","text":"","title":"unrest.generators.options"},{"location":"generators/#options","text":"Options(self, unrest) This generates an informative object on the unrest.UnRest instance used as reply for http OPTIONS request on the unrest API index.","title":"Options"},{"location":"idiom/","text":"unrest.idiom \uf0c1 Idiom \uf0c1 Idiom(self, rest) UnRest Idiom abstract class. Idioms are a way to alter how UnRest speaks with the rest of the world. The default implementation UnRestIdiom parses json from request and generates json from response. To implement an idiom you have to implement the request_to_payload and the data_to_response methods described below. You can also override the alter_query method to add functionality to the idiom based on the request . (i.e. implementing sort / filter query parameters) Arguments rest : The current rest instance request_to_payload \uf0c1 Idiom.request_to_payload(self, request) This method takes a Request request parameter and returns a payload dict. Arguments request : The Request request Returns A dict containing the request payload data. data_to_response \uf0c1 Idiom.data_to_response(self, data, request, status=200) This method takes a data dict returned by the route and return a Response object. Arguments data : The data dict returned by the route request : The original Request request status : The current status (500 if route raised an error) Returns An Response response object. alter_query \uf0c1 Idiom.alter_query(self, request, query) This method takes the request and the current query and returns a modified query from the request . Arguments data : The data dict returned by the route request : The original Request request status : The current status (500 if route raised an error) Returns The modified query . unrest.idiom.unrest \uf0c1 UnRestIdiom \uf0c1 UnRestIdiom(self, rest) The default UnRest implementation. Parses request payload as json. Serialize data as json. Can return a 404 on empty GET if empty_get_as_404 is set as True in the Unrest instance. unrest.idiom.yaml \uf0c1 YamlIdiom \uf0c1 YamlIdiom(self, rest) This is a very basic yaml implementation. It does the same thing as the UnRestIdiom but with yaml instead of json. Requires pyyaml to be installed. unrest.idiom.json_server \uf0c1 JsonServerIdiom \uf0c1 JsonServerIdiom(self, rest) The JSON Server idiom implementation. Currently support all basic queries and first-level (no nested props) filter, sort, pagination, slice, operators ( _gte , _lte , _ne , _like ) and q full-text search (which works better with SQLAlchemy-Searchable )","title":"Idioms"},{"location":"idiom/#unrestidiom","text":"","title":"unrest.idiom"},{"location":"idiom/#idiom","text":"Idiom(self, rest) UnRest Idiom abstract class. Idioms are a way to alter how UnRest speaks with the rest of the world. The default implementation UnRestIdiom parses json from request and generates json from response. To implement an idiom you have to implement the request_to_payload and the data_to_response methods described below. You can also override the alter_query method to add functionality to the idiom based on the request . (i.e. implementing sort / filter query parameters) Arguments rest : The current rest instance","title":"Idiom"},{"location":"idiom/#request_to_payload","text":"Idiom.request_to_payload(self, request) This method takes a Request request parameter and returns a payload dict. Arguments request : The Request request Returns A dict containing the request payload data.","title":"request_to_payload"},{"location":"idiom/#data_to_response","text":"Idiom.data_to_response(self, data, request, status=200) This method takes a data dict returned by the route and return a Response object. Arguments data : The data dict returned by the route request : The original Request request status : The current status (500 if route raised an error) Returns An Response response object.","title":"data_to_response"},{"location":"idiom/#alter_query","text":"Idiom.alter_query(self, request, query) This method takes the request and the current query and returns a modified query from the request . Arguments data : The data dict returned by the route request : The original Request request status : The current status (500 if route raised an error) Returns The modified query .","title":"alter_query"},{"location":"idiom/#unrestidiomunrest","text":"","title":"unrest.idiom.unrest"},{"location":"idiom/#unrestidiom_1","text":"UnRestIdiom(self, rest) The default UnRest implementation. Parses request payload as json. Serialize data as json. Can return a 404 on empty GET if empty_get_as_404 is set as True in the Unrest instance.","title":"UnRestIdiom"},{"location":"idiom/#unrestidiomyaml","text":"","title":"unrest.idiom.yaml"},{"location":"idiom/#yamlidiom","text":"YamlIdiom(self, rest) This is a very basic yaml implementation. It does the same thing as the UnRestIdiom but with yaml instead of json. Requires pyyaml to be installed.","title":"YamlIdiom"},{"location":"idiom/#unrestidiomjson_server","text":"","title":"unrest.idiom.json_server"},{"location":"idiom/#jsonserveridiom","text":"JsonServerIdiom(self, rest) The JSON Server idiom implementation. Currently support all basic queries and first-level (no nested props) filter, sort, pagination, slice, operators ( _gte , _lte , _ne , _like ) and q full-text search (which works better with SQLAlchemy-Searchable )","title":"JsonServerIdiom"},{"location":"rest/","text":"unrest.rest \uf0c1 Rest \uf0c1 Rest(self, unrest, Model, methods=['GET'], name=None, only=None, exclude=None, query=None, properties=None, relationships=None, allow_batch=False, auth=None, read_auth=None, write_auth=None, validators=None, validation_error_code=500, primary_keys=None, defaults=None, fixed=None, IdiomClass=<class 'unrest.idiom.unrest.UnRestIdiom'>, SerializeClass=<class 'unrest.coercers.Serialize'>, DeserializeClass=<class 'unrest.coercers.Deserialize'>) This is the entry point for generating a REST endpoint for a specific model The final uri if the path is '/api' and version 'v2' would be: /api/v2/model and /api/v2/model/pk1/pk2 and if model is not in the public schema /api/v2/schema/model and /api/v2/schema/model/pk1/pk2 . Usage: rest = UnRest(app) def name_validator(field): if len(field.value) > 12: raise field.ValidationError( 'Name is too long (max 12 characters).') return field.value rest(Person, only=['name', 'sex', 'age'], methods=rest.all, query=lambda q: q.filter(Person.age > 16), validators={'name': name_validator}) Arguments unrest : The unrest instance given automatically on UnRest call. Model : The sqlalchemy orm model class. methods : The allowed method list on this endpoint. Possible values are GET, PUT, POST, DELETE, PATCH and rest.all name : If specified replaces the model name in url. only : If specified restricts the json fields to this list. exclude : If specified removes the json fields in this list. query : A function that takes the Model query and returns your specific query. Can be useful to filter data for all the methods. properties : A list of additional properties to retrieve on the model. relationships : A mapping of relationships and rest endpoints to fetch with the model. allow_batch : Allow batch operations (PUT, DELETE and PATCH) without primary key. auth : A decorator that will always be called. read_auth : A decorator that will be called on GET. write_auth : A decorator that will be called on PUT, POST, DELETE and PATCH. validators : A mapping of field names and validation functions. A validator function takes a Validatable object as parameter and must return the final value for the field or raise a rest.ValidationError(reason) (where rest = Unrest() ) validation_error_code : The http return code when the validation fails. Defaults to 500 primary_keys : A list of column names to use as primary_keys (use real db primary keys by default) defaults : A mapping of column -> values which sets the default value of the columns when the column is not present in the payload. Can be a callable, in this case it will be called at runtime with the payload as argument. fixed : A mapping of column -> values which replaces the values present or not in the payload. Can be a callable, in this case it will be called at runtime with the payload as argument. SerializeClass : An alternative Serialize class. DeserializeClass : An alternative Deserialize class. columns \uf0c1 Gets all columns of this model column_property included. mapper \uf0c1 Get the SQLAlchemy mapper of this Model. name_parts \uf0c1 Returns a tuple containing optionally the schema of this table and its name. path \uf0c1 Gets the root path of this endpoint. primary_keys \uf0c1 This model primary keys names. query \uf0c1 Gets the current query associated to this Model. session \uf0c1 Shortcut property to the UnRest session. table \uf0c1 This Model table name. undefered_query \uf0c1 Gets the query with all attributes undefered. get \uf0c1 Rest.get(self, payload, **pks) The GET method With no arguments: Returns all query elements. (/api/model/) With primary keys: Returns the element in query with the primary keys. (/api/model/pk) Arguments payload : The request content ignored for GET. pks : The primary keys in url if any. put \uf0c1 Rest.put(self, payload, **pks) The PUT method With no arguments: If allow_batch set to true replace all the query elements with the ones in the request payload. With primary keys: Create or replace the element associated with the primary keys from the one in the request payload. Arguments payload : The request content containing new elements. pks : The primary keys in url if any. post \uf0c1 Rest.post(self, payload, **pks) The POST method With no arguments: Add element from request payload. With primary keys: Correspond to new collection creation. Unused. Arguments payload : The request content containing the new element. pks : The primary keys in url if any. delete \uf0c1 Rest.delete(self, payload, **pks) The DELETE method With no arguments: If allow_batch set to true delete all query elements. With primary keys: Delete the element associated with the primary keys. Arguments payload : The request content ignored in DELETE. pks : The primary keys of the element to delete. patch \uf0c1 Rest.patch(self, payload, **pks) The PATCH method With no arguments: If allow_batch set to true patch existing elements with element attributes specified in the request payload. With primary keys: Patch only one Arguments payload : The request content containing a list of attributes to be patched. pks : The primary keys of the element to patch. options \uf0c1 Rest.options(self, payload, **pks) The OPTIONS method Returns a description of this rest endpoint. declare \uf0c1 Rest.declare(self, method, manual_commit=False) A decorator to register an alternative method. The original is still callable with rest.{method} fruit = rest(Fruit) @fruit.declare('GET') def get(payload, fruit_id=None): rv = fruit.get(payload, fruit_id=fruit_id) return { 'occurences': rv['occurences'], 'objects': [ {'id': obj['fruit_id']} for obj in rv['objects'] ] } Arguments method : The method to override ('GET' for exemple) manual_commit : Don't auto commit after the method. sub \uf0c1 Rest.sub(self, query_factory, **kwargs) This methods return a copy of the current rest endpoint and takes a query_factory argument to alter the current query. Arguments query_factory : A function that takes the original query in parameter and returns a new query. **kwargs : Can be used to override Rest constructor arguments (query is not supported) Returns A Rest endpoint copied from this one parameters_to_pks \uf0c1 Rest.parameters_to_pks(self, parameters) Transform query parameters into primary keys mapping with deserialized values. deserialize \uf0c1 Rest.deserialize(self, payload, item, blank_missing=True) Deserialize the payload item in the provided item. Arguments payload : The payload containing the item object item : An instance of the model to put values in blank_missing : Set non-provided by payload item attributes at None deserialize_all \uf0c1 Rest.deserialize_all(self, payload) Deserialize all the payload items. Arguments payload : The payload containing the item list serialize \uf0c1 Rest.serialize(self, item) Serialize an item with the given SerializeClass serialize_all \uf0c1 Rest.serialize_all(self, items) Serialize all items and return a mapping containing: Returns A dict containing : objects: The serialized objects primary_keys: The list of primary keys defined for this rest endpoint occurences: The number of total occurences (without limit) offset if there's a query offset limit if there's a query limit set_defaults \uf0c1 Rest.set_defaults(self, payload, columns) Sets in payload item all the fixed and defaults values Validatable \uf0c1 Rest.Validatable(self, value, name, item, ValidationError) A validatable class that is used as validators argument. Arguments value : The current field value name : The current field name item : The current item ValidationError : The ValidationError Exception to raise on validation error. validate \uf0c1 Rest.validate(self, item, errors=None) Validates all validators columns against validators. Raise RestError if validation errors. validate_all \uf0c1 Rest.validate_all(self, items) Calls validate on all the items and raise an error if any does not validate. Arguments items : A list of item to validate Raises A RestError on validation error raise_error \uf0c1 Rest.raise_error(self, status, message, extra=None) Shortcut function to raise_error . wrap_route \uf0c1 Rest.wrap_route(self, method, route, manual_commit=False) Wrap a method route method ( get , post , put , delete , patch , options ) with a function that takes a Request as parameters and: converts request parameters into primary keys values calls the current idiom request_to_payload checks auth with read_auth , write_auth and auth if defined calls the wrapped method with the previously obtained payload commits the session if manual_commit is False and method is amongst modification ones and finally calls data_to_response with the return value of the wrapped function to return the Response Arguments method : The current http method route : The route associated with this http method manual_commit : Set this to True to prevent auto commit after route call Returns The Response of this request register_method \uf0c1 Rest.register_method(self, method, route=None, manual_commit=False) Register a route function associated with the http method . Arguments method : The http method to register the route with route : The route function, defaults to this rest.{method} manual_commit : Set this to True to prevent auto commit after route call has \uf0c1 Rest.has(self, pks) Returns whether the pks dict has values in it. get_from_pk \uf0c1 Rest.get_from_pk(self, query, **pks) Get the item from query that has **pks or None if not found. get_all_from_pks \uf0c1 Rest.get_all_from_pks(self, query, items_pks) Get all items from query correponding to the primary keys items_pks in one query. query_request \uf0c1 Rest.query_request(self, request) Context manager that sets the _query_alterer to the idiom alter_query and restore it to identity at exit.","title":"Rest entry points"},{"location":"rest/#unrestrest","text":"","title":"unrest.rest"},{"location":"rest/#rest","text":"Rest(self, unrest, Model, methods=['GET'], name=None, only=None, exclude=None, query=None, properties=None, relationships=None, allow_batch=False, auth=None, read_auth=None, write_auth=None, validators=None, validation_error_code=500, primary_keys=None, defaults=None, fixed=None, IdiomClass=<class 'unrest.idiom.unrest.UnRestIdiom'>, SerializeClass=<class 'unrest.coercers.Serialize'>, DeserializeClass=<class 'unrest.coercers.Deserialize'>) This is the entry point for generating a REST endpoint for a specific model The final uri if the path is '/api' and version 'v2' would be: /api/v2/model and /api/v2/model/pk1/pk2 and if model is not in the public schema /api/v2/schema/model and /api/v2/schema/model/pk1/pk2 . Usage: rest = UnRest(app) def name_validator(field): if len(field.value) > 12: raise field.ValidationError( 'Name is too long (max 12 characters).') return field.value rest(Person, only=['name', 'sex', 'age'], methods=rest.all, query=lambda q: q.filter(Person.age > 16), validators={'name': name_validator}) Arguments unrest : The unrest instance given automatically on UnRest call. Model : The sqlalchemy orm model class. methods : The allowed method list on this endpoint. Possible values are GET, PUT, POST, DELETE, PATCH and rest.all name : If specified replaces the model name in url. only : If specified restricts the json fields to this list. exclude : If specified removes the json fields in this list. query : A function that takes the Model query and returns your specific query. Can be useful to filter data for all the methods. properties : A list of additional properties to retrieve on the model. relationships : A mapping of relationships and rest endpoints to fetch with the model. allow_batch : Allow batch operations (PUT, DELETE and PATCH) without primary key. auth : A decorator that will always be called. read_auth : A decorator that will be called on GET. write_auth : A decorator that will be called on PUT, POST, DELETE and PATCH. validators : A mapping of field names and validation functions. A validator function takes a Validatable object as parameter and must return the final value for the field or raise a rest.ValidationError(reason) (where rest = Unrest() ) validation_error_code : The http return code when the validation fails. Defaults to 500 primary_keys : A list of column names to use as primary_keys (use real db primary keys by default) defaults : A mapping of column -> values which sets the default value of the columns when the column is not present in the payload. Can be a callable, in this case it will be called at runtime with the payload as argument. fixed : A mapping of column -> values which replaces the values present or not in the payload. Can be a callable, in this case it will be called at runtime with the payload as argument. SerializeClass : An alternative Serialize class. DeserializeClass : An alternative Deserialize class.","title":"Rest"},{"location":"rest/#columns","text":"Gets all columns of this model column_property included.","title":"columns"},{"location":"rest/#mapper","text":"Get the SQLAlchemy mapper of this Model.","title":"mapper"},{"location":"rest/#name_parts","text":"Returns a tuple containing optionally the schema of this table and its name.","title":"name_parts"},{"location":"rest/#path","text":"Gets the root path of this endpoint.","title":"path"},{"location":"rest/#primary_keys","text":"This model primary keys names.","title":"primary_keys"},{"location":"rest/#query","text":"Gets the current query associated to this Model.","title":"query"},{"location":"rest/#session","text":"Shortcut property to the UnRest session.","title":"session"},{"location":"rest/#table","text":"This Model table name.","title":"table"},{"location":"rest/#undefered_query","text":"Gets the query with all attributes undefered.","title":"undefered_query"},{"location":"rest/#get","text":"Rest.get(self, payload, **pks) The GET method With no arguments: Returns all query elements. (/api/model/) With primary keys: Returns the element in query with the primary keys. (/api/model/pk) Arguments payload : The request content ignored for GET. pks : The primary keys in url if any.","title":"get"},{"location":"rest/#put","text":"Rest.put(self, payload, **pks) The PUT method With no arguments: If allow_batch set to true replace all the query elements with the ones in the request payload. With primary keys: Create or replace the element associated with the primary keys from the one in the request payload. Arguments payload : The request content containing new elements. pks : The primary keys in url if any.","title":"put"},{"location":"rest/#post","text":"Rest.post(self, payload, **pks) The POST method With no arguments: Add element from request payload. With primary keys: Correspond to new collection creation. Unused. Arguments payload : The request content containing the new element. pks : The primary keys in url if any.","title":"post"},{"location":"rest/#delete","text":"Rest.delete(self, payload, **pks) The DELETE method With no arguments: If allow_batch set to true delete all query elements. With primary keys: Delete the element associated with the primary keys. Arguments payload : The request content ignored in DELETE. pks : The primary keys of the element to delete.","title":"delete"},{"location":"rest/#patch","text":"Rest.patch(self, payload, **pks) The PATCH method With no arguments: If allow_batch set to true patch existing elements with element attributes specified in the request payload. With primary keys: Patch only one Arguments payload : The request content containing a list of attributes to be patched. pks : The primary keys of the element to patch.","title":"patch"},{"location":"rest/#options","text":"Rest.options(self, payload, **pks) The OPTIONS method Returns a description of this rest endpoint.","title":"options"},{"location":"rest/#declare","text":"Rest.declare(self, method, manual_commit=False) A decorator to register an alternative method. The original is still callable with rest.{method} fruit = rest(Fruit) @fruit.declare('GET') def get(payload, fruit_id=None): rv = fruit.get(payload, fruit_id=fruit_id) return { 'occurences': rv['occurences'], 'objects': [ {'id': obj['fruit_id']} for obj in rv['objects'] ] } Arguments method : The method to override ('GET' for exemple) manual_commit : Don't auto commit after the method.","title":"declare"},{"location":"rest/#sub","text":"Rest.sub(self, query_factory, **kwargs) This methods return a copy of the current rest endpoint and takes a query_factory argument to alter the current query. Arguments query_factory : A function that takes the original query in parameter and returns a new query. **kwargs : Can be used to override Rest constructor arguments (query is not supported) Returns A Rest endpoint copied from this one","title":"sub"},{"location":"rest/#parameters_to_pks","text":"Rest.parameters_to_pks(self, parameters) Transform query parameters into primary keys mapping with deserialized values.","title":"parameters_to_pks"},{"location":"rest/#deserialize","text":"Rest.deserialize(self, payload, item, blank_missing=True) Deserialize the payload item in the provided item. Arguments payload : The payload containing the item object item : An instance of the model to put values in blank_missing : Set non-provided by payload item attributes at None","title":"deserialize"},{"location":"rest/#deserialize_all","text":"Rest.deserialize_all(self, payload) Deserialize all the payload items. Arguments payload : The payload containing the item list","title":"deserialize_all"},{"location":"rest/#serialize","text":"Rest.serialize(self, item) Serialize an item with the given SerializeClass","title":"serialize"},{"location":"rest/#serialize_all","text":"Rest.serialize_all(self, items) Serialize all items and return a mapping containing: Returns A dict containing : objects: The serialized objects primary_keys: The list of primary keys defined for this rest endpoint occurences: The number of total occurences (without limit) offset if there's a query offset limit if there's a query limit","title":"serialize_all"},{"location":"rest/#set_defaults","text":"Rest.set_defaults(self, payload, columns) Sets in payload item all the fixed and defaults values","title":"set_defaults"},{"location":"rest/#validatable","text":"Rest.Validatable(self, value, name, item, ValidationError) A validatable class that is used as validators argument. Arguments value : The current field value name : The current field name item : The current item ValidationError : The ValidationError Exception to raise on validation error.","title":"Validatable"},{"location":"rest/#validate","text":"Rest.validate(self, item, errors=None) Validates all validators columns against validators. Raise RestError if validation errors.","title":"validate"},{"location":"rest/#validate_all","text":"Rest.validate_all(self, items) Calls validate on all the items and raise an error if any does not validate. Arguments items : A list of item to validate Raises A RestError on validation error","title":"validate_all"},{"location":"rest/#raise_error","text":"Rest.raise_error(self, status, message, extra=None) Shortcut function to raise_error .","title":"raise_error"},{"location":"rest/#wrap_route","text":"Rest.wrap_route(self, method, route, manual_commit=False) Wrap a method route method ( get , post , put , delete , patch , options ) with a function that takes a Request as parameters and: converts request parameters into primary keys values calls the current idiom request_to_payload checks auth with read_auth , write_auth and auth if defined calls the wrapped method with the previously obtained payload commits the session if manual_commit is False and method is amongst modification ones and finally calls data_to_response with the return value of the wrapped function to return the Response Arguments method : The current http method route : The route associated with this http method manual_commit : Set this to True to prevent auto commit after route call Returns The Response of this request","title":"wrap_route"},{"location":"rest/#register_method","text":"Rest.register_method(self, method, route=None, manual_commit=False) Register a route function associated with the http method . Arguments method : The http method to register the route with route : The route function, defaults to this rest.{method} manual_commit : Set this to True to prevent auto commit after route call","title":"register_method"},{"location":"rest/#has","text":"Rest.has(self, pks) Returns whether the pks dict has values in it.","title":"has"},{"location":"rest/#get_from_pk","text":"Rest.get_from_pk(self, query, **pks) Get the item from query that has **pks or None if not found.","title":"get_from_pk"},{"location":"rest/#get_all_from_pks","text":"Rest.get_all_from_pks(self, query, items_pks) Get all items from query correponding to the primary keys items_pks in one query.","title":"get_all_from_pks"},{"location":"rest/#query_request","text":"Rest.query_request(self, request) Context manager that sets the _query_alterer to the idiom alter_query and restore it to identity at exit.","title":"query_request"},{"location":"unrest/","text":"unrest \uf0c1 UnRest \uf0c1 UnRest(self, app=None, session=None, path='/api', version='', framework=None, IdiomClass=None, SerializeClass=None, DeserializeClass=None, RestClass=<class 'unrest.rest.Rest'>, allow_options=True, serve_openapi_file=True, openapi_class=<class 'unrest.generators.openapi.OpenApi'>, options_class=<class 'unrest.generators.options.Options'>, empty_get_as_404=False, info={}) A troubling rest api library for sqlalchemy models. This is the main entry point of unrest. Common usage is as following: rest = UnRest(app, session) # app is your application # When called, it instanciate a `Rest` object that will register the # REST endpoints. See the `Rest` class. rest(Model1) rest(Model2) Arguments app : Your web application, can be set afterwards using init_app session : Your sqlalchemy session, can be set afterwards using init_session and init_session method. path : Default '/api', sets the root url path for your endpoints version : Adds a version to the root url path if specified (i.e. /api/v2) framework : A specific framework class, defaults to auto detect. IdiomClass : An idiom class, defaults to unrest.idiom.unrest . SerializeClass : A global alternative for Serialize class. DeserializeClass : A global alternative for Deserialize class. RestClass : Replace the default Rest class. allow_options : Set it to False to disable OPTIONS requests. serve_openapi_file : Set it to False to disable openapi file generation. empty_get_as_404 : If True return a 404 on get with id not found info : Additional info for the openapi metadata. Frameworks Unrest aims to be framework agnostic. It currently works with Flask out of the box and provides some other frameworks: Tornado and python http.server. See Framework all \uf0c1 Return all supported methods. Useful for the rest method keyword argument. root_path \uf0c1 Returns this API root path. Property \uf0c1 UnRest.Property(self, name, type=None, formatter=None) A Property wrapper used instead of a string in a Rest properties parameter. Arguments name : This property name type : The sqlalchemy type used for type coercion formatter : An optional function to transform the parameter as string RestError \uf0c1 UnRest.RestError(self, status, message, extra=None) Exception raised by rest methods. It's catched by the REST method wrapper and will return a status http error with the specified message . ValidationError \uf0c1 UnRest.ValidationError(self, message) Exception raised by rest validation methods. init_app \uf0c1 UnRest.init_app(self, app) Sets the app on UnRest if it was missing during instantiation. init_session \uf0c1 UnRest.init_session(self, session) Sets the sqlalchemy session on UnRest if it was missing during instantiation. raise_error \uf0c1 UnRest.raise_error(self, status, message, extra=None) Raise an error that will be handled by the rest wrapper, which will return a json response with status as HTTP status code and message as content. Arguments status : The http status code corresponding to the error (404 for instance) message : The message that will be returned in the json response extra : Mapping of extra fields to return in json response register_index \uf0c1 UnRest.register_index(self) Register the API index GET route. index \uf0c1 UnRest.index(self, request) The API index GET route. send_json \uf0c1 UnRest.send_json(self, data) Send data as json. Arguments data : An object to send as json Returns The Response containing the json data register_options \uf0c1 UnRest.register_options(self) Register the API index OPTIONS route. options \uf0c1 UnRest.options(self, request) The API index OPTIONS route. register_openapi \uf0c1 UnRest.register_openapi(self) Register the openapi route. openapi \uf0c1 UnRest.openapi(self, request) The API openapi route. call \uf0c1 UnRest.__call__(self, *args, **kwargs) Returns a Rest instance. See rest entry points.","title":"UnRest"},{"location":"unrest/#unrest","text":"","title":"unrest"},{"location":"unrest/#unrest_1","text":"UnRest(self, app=None, session=None, path='/api', version='', framework=None, IdiomClass=None, SerializeClass=None, DeserializeClass=None, RestClass=<class 'unrest.rest.Rest'>, allow_options=True, serve_openapi_file=True, openapi_class=<class 'unrest.generators.openapi.OpenApi'>, options_class=<class 'unrest.generators.options.Options'>, empty_get_as_404=False, info={}) A troubling rest api library for sqlalchemy models. This is the main entry point of unrest. Common usage is as following: rest = UnRest(app, session) # app is your application # When called, it instanciate a `Rest` object that will register the # REST endpoints. See the `Rest` class. rest(Model1) rest(Model2) Arguments app : Your web application, can be set afterwards using init_app session : Your sqlalchemy session, can be set afterwards using init_session and init_session method. path : Default '/api', sets the root url path for your endpoints version : Adds a version to the root url path if specified (i.e. /api/v2) framework : A specific framework class, defaults to auto detect. IdiomClass : An idiom class, defaults to unrest.idiom.unrest . SerializeClass : A global alternative for Serialize class. DeserializeClass : A global alternative for Deserialize class. RestClass : Replace the default Rest class. allow_options : Set it to False to disable OPTIONS requests. serve_openapi_file : Set it to False to disable openapi file generation. empty_get_as_404 : If True return a 404 on get with id not found info : Additional info for the openapi metadata. Frameworks Unrest aims to be framework agnostic. It currently works with Flask out of the box and provides some other frameworks: Tornado and python http.server. See Framework","title":"UnRest"},{"location":"unrest/#all","text":"Return all supported methods. Useful for the rest method keyword argument.","title":"all"},{"location":"unrest/#root_path","text":"Returns this API root path.","title":"root_path"},{"location":"unrest/#property","text":"UnRest.Property(self, name, type=None, formatter=None) A Property wrapper used instead of a string in a Rest properties parameter. Arguments name : This property name type : The sqlalchemy type used for type coercion formatter : An optional function to transform the parameter as string","title":"Property"},{"location":"unrest/#resterror","text":"UnRest.RestError(self, status, message, extra=None) Exception raised by rest methods. It's catched by the REST method wrapper and will return a status http error with the specified message .","title":"RestError"},{"location":"unrest/#validationerror","text":"UnRest.ValidationError(self, message) Exception raised by rest validation methods.","title":"ValidationError"},{"location":"unrest/#init_app","text":"UnRest.init_app(self, app) Sets the app on UnRest if it was missing during instantiation.","title":"init_app"},{"location":"unrest/#init_session","text":"UnRest.init_session(self, session) Sets the sqlalchemy session on UnRest if it was missing during instantiation.","title":"init_session"},{"location":"unrest/#raise_error","text":"UnRest.raise_error(self, status, message, extra=None) Raise an error that will be handled by the rest wrapper, which will return a json response with status as HTTP status code and message as content. Arguments status : The http status code corresponding to the error (404 for instance) message : The message that will be returned in the json response extra : Mapping of extra fields to return in json response","title":"raise_error"},{"location":"unrest/#register_index","text":"UnRest.register_index(self) Register the API index GET route.","title":"register_index"},{"location":"unrest/#index","text":"UnRest.index(self, request) The API index GET route.","title":"index"},{"location":"unrest/#send_json","text":"UnRest.send_json(self, data) Send data as json. Arguments data : An object to send as json Returns The Response containing the json data","title":"send_json"},{"location":"unrest/#register_options","text":"UnRest.register_options(self) Register the API index OPTIONS route.","title":"register_options"},{"location":"unrest/#options","text":"UnRest.options(self, request) The API index OPTIONS route.","title":"options"},{"location":"unrest/#register_openapi","text":"UnRest.register_openapi(self) Register the openapi route.","title":"register_openapi"},{"location":"unrest/#openapi","text":"UnRest.openapi(self, request) The API openapi route.","title":"openapi"},{"location":"unrest/#call","text":"UnRest.__call__(self, *args, **kwargs) Returns a Rest instance. See rest entry points.","title":"call"},{"location":"util/","text":"Request \uf0c1 Request(self, url, method, parameters, query, payload, headers) The unrest request object created in the unrest.framework route wrapper. Arguments url : The request url. method : The request method. parameters : The url parameters as dict. query : The query string parameters as dict. payload : The request body as bytes if any. headers : A mapping of request headers. Response \uf0c1 Response(self, payload, headers, status) The unrest response object created by the unrest.idiom . Arguments payload : The response body as string. headers : A mapping of response headers. status : The response status code.","title":"Util"},{"location":"util/#request","text":"Request(self, url, method, parameters, query, payload, headers) The unrest request object created in the unrest.framework route wrapper. Arguments url : The request url. method : The request method. parameters : The url parameters as dict. query : The query string parameters as dict. payload : The request body as bytes if any. headers : A mapping of request headers.","title":"Request"},{"location":"util/#response","text":"Response(self, payload, headers, status) The unrest response object created by the unrest.idiom . Arguments payload : The response body as string. headers : A mapping of response headers. status : The response status code.","title":"Response"}]}